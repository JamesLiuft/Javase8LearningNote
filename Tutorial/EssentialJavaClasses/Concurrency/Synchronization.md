### 同步
线程主要通过共享对字段和对象引用字段的访问来进行通信。这种通信形式非常高效，但会导致两种错误：线程干扰和内存一致性错误。防止这些错误所需的工具是同步。

但是，同步可能会引入线程争用，当两个或多个线程尝试同时访问同一资源并导致 Java 运行时执行一个或多个线程更慢，甚至暂停它们的执行时，就会发生这种争用。饥饿和活锁是线程争用的形式。有关更多信息，请参阅<a href="">活跃性</a>部分。

#### 本节涵盖以下主题：
· 线程干扰(Thread Interference)-描述了当多个线程访问共享数据时如何引入错误。

· 内存一致性错误(Memory Consistency Errors)-描述了由共享内存的不一致视图导致的错误。

· 同步方法(Synchronized Methods)-描述了一个简单的习惯用法，可以有效防止线程干扰和内存一致性错误。

· 隐式锁和同步(Implicit Locks and Synchronization)-描述了一种更通用的同步习语，并描述了同步是如何基于隐式锁的。

· 原子访问(Atomic Access)-讨论了不能被其他线程干扰的操作的一般概念。

#### 线程干扰(Thread Interference)

#### 内存一致性错误(Memory Consistency Errors)

#### 同步方法(Synchronized Methods)
Java 编程语言提供了两种基本的同步习惯用法：同步方法和同步语句。下一节将介绍这两个语句中更复杂的同步语句。本节介绍同步方法。

要使方法同步，只需将 synchronized 关键字添加到其声明中：

```
public class SynchronizedCounter {
    private int c = 0;

    public synchronized void increment() {
        c++;
    }

    public synchronized void decrement() {
        c--;
    }

    public synchronized int value() {
        return c;
    }
}
```
如果 count 是 SynchronizedCounter 的一个实例，那么使这些方法同步有两个效果：

· 首先，同一对象上的同步方法的两次调用不可能交错。当一个线程正在为一个对象执行同步方法时，所有其他为同一对象调用同步方法的线程都会阻塞（暂停执行），直到第一个线程处理完该对象。

· 其次，当同步方法退出时，它会自动与任何后续对同一对象的同步方法调用建立起之前的关系。这保证了对象状态的更改对所有线程都是可见的。

<b>请注意，构造函数不能同步——在构造函数中使用 synchronized 关键字是一个语法错误。同步构造函数没有意义，因为只有创建对象的线程才能在构造对象时访问它。</b>

---
警告：当构造一个将在线程之间共享的对象时，要非常小心不要对对象的引用过早地“泄漏”。例如，假设您要维护一个名为实例的列表，其中包含类的每个实例。您可能想在构造函数中添加以下行：

```
instances.add(this);
```
但是在对象的构造完成之前，其他线程可以使用实例来访问对象。

---
同步方法启用了一种防止线程干扰和内存一致性错误的简单策略：如果一个对象对多个线程可见，则对该对象变量的所有读取或写入都通过同步方法完成。 （一个重要的例外：final 字段，在对象构建后无法修改，可以通过非同步方法安全地读取，一旦对象被构建）这种策略是有效的，但会带来活性问题，正如我们将见本课后面。
#### 内在锁和同步(Intrinsic Locks and Synchronization)
同步是围绕称为内在锁或监视器锁的内部实体构建的。 （API 规范通常将此实体简称为“监视器”。）内在锁在同步的两个方面都发挥作用：强制对对象状态的独占访问和建立对可见性至关重要的先发生关系。

每个对象都有一个与之关联的内在锁。按照惯例，需要对对象字段进行排他和一致访问的线程必须在访问对象之前获取对象的内在锁，然后在完成访问时释放内在锁。在获得锁和释放锁之间，线程被称为拥有内在锁。只要一个线程拥有一个内在锁，其他线程就不能获得相同的锁。另一个线程在尝试获取锁时会阻塞。

当线程释放内在锁时，会在该操作和任何后续获取相同锁之间建立起之前的关系。

##### 同步方法中的锁(Locks In Synchronized Methods)

当线程调用同步方法时，它会自动获取该方法对象的内在锁，并在方法返回时释放它。即使返回是由未捕获的异常引起的，也会发生锁定释放。

您可能想知道调用静态同步方法时会发生什么，因为静态方法与类相关联，而不是与对象相关联。在这种情况下，线程获取与该类关联的 Class 对象的内在锁。因此，对类的静态字段的访问由与类的任何实例的锁不同的锁控制。
##### 同步语句(Synchronized Statements)

创建同步代码的另一种方法是使用同步语句。与同步方法不同，同步语句必须指定提供内在锁的对象：

```
public void addName(String name) {
    synchronized(this) {
        lastName = name;
        nameCount++;
    }
    nameList.add(name);
}
```
在这个例子中，addName 方法需要同步对lastName 和nameCount 的更改，但也需要避免同步调用其他对象的方法。 （从同步代码中调用其他对象的方法可能会产生问题，这在 Liveness 部分中进行了描述。）如果没有同步语句，就必须有一个单独的、非同步的方法来调用 nameList.add。

同步语句对于通过细粒度同步提高并发性也很有用。例如，假设 MsLunch 类有两个从未一起使用的实例字段 c1 和 c2。这些字段的所有更新都必须同步，但没有理由阻止 c1 的更新与 c2 的更新交错 - 这样做会通过创建不必要的阻塞来降低并发性。我们不使用同步方法或以其他方式使用与此关联的锁，而是创建两个对象来提供锁。

```
public class MsLunch {
    private long c1 = 0;
    private long c2 = 0;
    private Object lock1 = new Object();
    private Object lock2 = new Object();

    public void inc1() {
        synchronized(lock1) {
            c1++;
        }
    }

    public void inc2() {
        synchronized(lock2) {
            c2++;
        }
    }
}
```

非常小心地使用这个惯用语法。您必须绝对确定交错访问受影响的字段确实是安全的。


#### 原子访问(Atomic Access)